[{"토픽":"Unix 부팅과정","키워드":"바 엠 그 커 이 런","도식":null,"정의":null,"내용":"BIOS (Basic IO System, sys 무결 검사)\nMBR (Master Boot Record)\nGRUB (Grand Unified 부트로더, 커널 image 선택)\n커널 (루트 파일시스템 마운트, \/sbin\/init 실행)\nINIT (PID1 실행, Run Level 결정)\nRun Level(프로그램 실행)"},{"토픽":"Unix Run Level","키워드":"종 단 다 다 예 G 리 단","도식":null,"정의":"Init 파일에 저장된, 부팅 시 프로그램 실행 레벨","내용":"0(시스템 종료)\n1(단일사용자)\n2(다중사용자, 비NW) \n3(다중사용자, NW모드 포함)\n4(특정용도 위한 예약)\n5(GUI 로그인을 위해 사용, 3이랑 비슷)\n6(Reboot)\nS(단일사용자 모드, 모든 파일시스템 마운트, 엑세스 가능)"},{"토픽":"UNIX 핵심 컴포넌트","키워드":"커 쉘 유","도식":null,"정의":"멀티 유저용 시분할 처리 위해 시스템 내부적으로 주요 단일 기능 제공하는 시스템 핵심 모듈","내용":"커널\n쉘(시스템 라이브러리. 앱이 커널 통해 사용가능 함수. 파일 열기\/쓰기, 프로세스 종료, 프로그램 실행 등)\n시스템 유틸리티(개별, 특정 및 특수 관리 작업을 실행하는 프로그램 집합 : System SW, User Utility, 컴파일러, 디버거)"},{"토픽":"리눅스 물리적 개념 구조","키워드":"앱 시 커 하","도식":null,"정의":null,"내용":"App\nSystem Call I\/F(App에 커널 서비스 제공)\n커널\nHW(CPU, RAM, HDD)"},{"토픽":"리눅스 논리적 트리 구조","키워드":"앜 이 엠 엪 드","도식":null,"정의":null,"내용":"arch\/(CPU 종속적),\ninit\/(HW 독립적인 커널 초기화 루틴),\nmm\/(HW 독립적인 메모리 관리 루틴),\nfs\/(가상 파일 시스템)\ndrivers\/(장치 드라이버 루틴)"},{"토픽":"커널","키워드":"자 핵 추\n코 프 메\n루 네 파 디","도식":null,"정의":"OS의 핵심부분으로 다른 모듈 및 응용 프로그램 수행에 필요한 여러 서비스를 제공하는 소프트웨어","내용":"자원관리 : CPU, Mem, Disk, Device\n핵심사항 처리 : 스케줄링, 입출력 제어, 프로세스 관리\n추상화 : OS의 복잡성 감추고 HW에 일관성 있는 I\/F 제공\n\nCore Area(프로세스, Mem)\/Rural(NW, File Sys, Device)"},{"토픽":"커널 종류","키워드":"모 하 마 엑\n하 리 비\n마 아 심\n엑 미","도식":null,"정의":null,"내용":"Monolithic : OS 모든 기능 같은 주소공간(UNIX, Linux, AIX)\nHybrid : 마이크로 커널 + 기능 추가(ReactOS, BeOS)\nMicro : 프로세스\/Mem 기능만 커널(AmigaOS, 심비안 OS)\nExo : 추상 제일 ↓, 개발자에 HW 결정권 많이(MirageOS)"},{"토픽":"유니 커널","키워드":"립 런 앱","도식":null,"정의":"특정 APP에 특화된, App과 커널이 분리 안되고 단일 주소공간을 공유하는 Library OS 기반 시스템 이미지","내용":"특정 App에 최적화, App이 필요한 lib만 가짐\n구성 : libOS(커널 기능), 런타임 lib(APP 실행에 필요), App\n작은 실행 이미지, 빠른 부팅\n불필요한 커널 기능이 없어 공격 대상이 작아 보안에도 강함"},{"토픽":"커널과 APP 간 통신 방법","키워드":"블 완 논 즉\n싱 요 아 받","도식":null,"정의":null,"내용":"Block : 요청 시 일단 Block, 작업 완료 후 응답 받을 수 있음\nNon block : 작업 요청 시 즉시 응답 돌아옴\nSync : 작업 요청한 측(유저)이 작업 완료 여부 체크(Call)\nAsync : 작업 요청받은 측(커널)이 작업 완료 여부 Callback"},{"토픽":"병행 컴퓨팅 시 컴퓨터 보호","키워드":"이 엠 타","도식":null,"정의":"CPU 하나가 여러 프로그램 실행 시 타 프로그램의 STOP, HALT 등으로 인한 장애 방지","내용":"HW(I\/O 등), OS 보호 : 이중모드\n메모리 보호 : MMU\n한 프로그램의 CPU 독점 보호 : Timer"},{"토픽":"이중 모드","키워드":"앱 시 커 하\n0 12 3 - 커 장 유","도식":null,"정의":"다중 프로그래밍 환경에서 사용자 모드\/커널 모드로 분리, 자원 접근 시 OS 보호 기법","내용":"보호링(접근수준) : Ring 0(커널), 1,2(장치driver), 3(유저)\n특권 명령 : Stop, Halt, Reset, Set_Timer 등\nUser App ↔ System Call Interface ↔ 커널(HW관리)\n레지스터의 Mode bit이 0이면 커널, 1이면 유저"},{"토픽":"MMU","키워드":"베 리\n내 아 종","도식":null,"정의":"메모리 보호 위해 Base, Limit 레지스터를 통해 프로세스가 자기주소만 접근 하게 하는 기법\/하드웨어 칩","내용":"Base + limit 범위 내 : MEM 접근, data를 CPU에 전달\n범위밖 : 내부 인터럽 > CPU는 ISR로 이동 > 프로세스 강종\nBase랑 Limit 값은 관리자 모드의 OS에서만 접근 가능"},{"토픽":"MMU 구성요소","키워드":"A P C R W M","도식":null,"정의":null,"내용":"Address Translation : 가상메모리 주소를 물리 메모리 주소로 변환\nPrivilege Control : 사용자 프로그램의 커널 영역 침범 방지\nCache Control : 캐시 가능 영역 \/ 불가능 영역 설정, 제어\nRead Protection : Read 할 수 없는 영역을 생성\nWrite Protection : Writer 할 수 없는 영역을 생성\nMemory Protection : 각 프로세스 별 접근 가능 메모리 영역 할당"},{"토픽":"Timer","키워드":"시 감 이","도식":null,"정의":"유저 앱의 무한반복으로 인한 CPU 독점 방지 위해 일정 시간 후 강제로 CPU 제어권 이양시키는 기법","내용":"타이머에 정해진 시간 설정 > 클락마다 타이머 1씩 감소\n> 타이머 0 될 시 OS에 CPU 제어권 이양\n예시 : while(1){ ...\/\/} > 무한 반복 발생(실수 or 고의)"},{"토픽":"가상 메모리 관리기법","키워드":"호 배 할 교\nFi L L O N S","도식":null,"정의":"Disk 활용한 가상 mem 사용 시 MEM 호출, 배치, 할당, 교체 등 관리 기법","내용":"호출 : 요구, 예상(Disk에서 MM으로의 적재 시기)\n배치 : 최적, 최악, 최초(MM에 적재할 곳 결정)\n할당 : 연속할당 - 고정\/가변, 분산할당 - 페이징\/세그먼트\n교체 : FIFO, LRU, LFU, OPT(사용 안할거 예측), NUR, SCR"},{"토픽":"Belady's Anomaly\n\nFIFO Anomaly","키워드":"0, 1, 2, 3, 0, 1, 4, 0, 1, 2, 3 ,4","도식":null,"정의":"FIFO 페이지 교체 시, Frame 수를 늘렸는데 오히려 Page Fault가 증가하는 이상 현상","내용":null},{"토픽":"SCR\n(Second Chance Replacement)\n2차 기회","키워드":"참 일 세 환","도식":null,"정의":"FIFO 단점 극복, MM에 오래 있었으나 자주 사용되는 페이지의 교체를 방지하기 위해 참조 비트를 추가로 설정하는 기법","내용":"각 Page마다 참조 비트 + FIFO 기법 사용\n- Bit 0일 시 교체, 1일 시 Bit만 0으로 변경\n- 다음 번 교체 시 참조 Bit가 또 1이면 또 Second Chance\n- 참조가 0인 Page를 계속 순환 탐색하므로 환형 큐 사용"},{"토픽":"NUR\n(Not Used Recently)","키워드":"참 변","도식":null,"정의":"LRU와 유사하게, 최근에 사용하지 않은 페이지를 교체하는 기법","내용":"각 Page마다 참조(Reference), 변형(Modified) 비트 사용\n- 참조 : 호출 안되면 0, 호출되면 1 지정\n- 변형 : Page 내용 변경 없을 시 0, 변경 시 1 지정\n* 참조가 변형보다 우선, 참조도 변형도 안된게 1순위 교체\n\n특징\n\n- 적은 오버헤드로 적절한 성능을 낼 수 있음\n- LRU와 유사하면서도 실제로 자주 쓰임\n- 동일 그룸 내에서의 선택은 무작위\n- 모든 참조 비트 r을 주기적으로 0으로 변경"},{"토픽":"OPT\n(Optimal page replacement algorithm)\n최적 페이지 교체","키워드":null,"도식":null,"정의":"미래에 가장 오랫동안 사용되지 않을 페이지를  교체하는 기법","내용":"가장 최적의 교체 방안\nBut, SJF랑 똑같이, 미래를 알아야 해서 구현 어려움\n* SJF는 누가 언제 끝나는지를 미리 다 알아야 함"},{"토픽":"메모리단편화","키워드":"외 내","도식":null,"정의":"RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태","내용":"내부단편화 : 프로세스가 필요한 양보다 더 큰 메모리가 할당\n\n외부단편화 : 메모리 공간은 충분하지만 실제로 할당이 불가한 상황"},{"토픽":"단편화 해결방법","키워드":"통 압 풀 \/ 슬 버\n\n내 슬 외 버","도식":null,"정의":"RAM에서 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 존재함에도 할당 불가 상태","내용":"내외부 공통 : 통합(인접), 압축(분산), 메모리 pool(1K, 4K, 8K 등 다양한 메모리 풀 미리 생성한 후 사용하고 반납)\n내부 : Slab 프레임별로 필요 mem마다 작게 분할해 할당\n외부 : 버디 메모리(2의 거듭제곱 크기로 분할해 할당)\n* 요청 크기가 4KB보다 크면 버디, 작으면 Slab 할당"},{"토픽":"Slab Allocator","키워드":"캐 페 오","도식":null,"정의":"고정크기 메모리 블록을 pool에 미리 할당 후 요청 시 가장 비슷한 조각 주는 커널의 동적 메모리 할당자","내용":"Slab 캐시 > Slab Page N개 > Slab Object N개\n- 캐시 : 자주 쓰는 메모리 패턴(크기) 미리 할당\/관리 주체\n- Page : Object로 구성된 page(4KB, Order-N 단위)\n- Object : 캐시가 할당해 둔 메모리\n* 한 Page 내 Obj 크기는 동일, 타 Page obj는 다를 수 있음"},{"토픽":"스레싱\n(Thrashing)","키워드":"C 추 교 폴\n웤 피","도식":null,"정의":"너무 많은 Page Fault로 프로세스 수행시간보다 페이지 교체 시간이 많은 상태","내용":"OS가 CPU 이용률 검사 > 이용률 낮아 프로세스 추가\n> 기존 프로세스 사용 page 교체 > Page Fault 증가...\n해결 : Working Set, PFF(페이지 폴트 빈도)"},{"토픽":"Working Set","키워드":null,"도식":null,"정의":"스레싱 해결 위해 지역성을 기반으로 자주 사용한 페이지 집합을 MM에 상주시키는 방법","내용":"워킹셋 : 메모리에 있어야 하는 페이지들 집합\n워킹셋 윈도우 : Reference할 page의 수 \/ △(델타)로 표시\n워킹셋 사이즈 : 워킹셋 내 page 수(예시에서는 2)"},{"토픽":"지역성","키워드":"시 공 순","도식":null,"정의":"CPU가 기억장치의 특정 부분에 위치한 데이터나 프로그램 코드를 집중적으로 액세스하는 현상\n\n컴퓨터의 구성요소 간 속도 차이로 인한 병목현상이 발생하지만 Locality의 특성을 이용하여 고비용\/고속 저장장치의 효율적 사용 및 속도 향상 가능","내용":"시간 : Loop문, 서브루틴, 스택 \/ LRU, 캐시(CDN, TLB) 활용\n최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스\n공간 : 배열, 관련 변수 선언 \/ 워킹셋에 활용\n액세스된 기억장소와 인접한 기억장소가 액세스\n순차 : 순차적 코드 실행(data, 명령어 순차적 access)\n분기가 발생하지 않는 한, 명령어들은 기억장치에 저장된 순서대로 인출\n\n목표\n빠른 접근 시간 : Cache Access Time의 최소화\n적중률 최대화 : Cache Hit Rate의 최대화"},{"토픽":"PFF\n(Page Fault Frequency)","키워드":null,"도식":null,"정의":"스레싱 해결 위해 Page Fault 빈도와 Frame 낭비 간 적정선을 유지하는 기법","내용":"[Page Fault Rate, 할당한 Frame 수]로 만든 그래프\n상한선 넘어가면 Frame 늘리고, 하한선 밑이면 Frame 줄임"},{"토픽":"가상메모리 주소 물리 변환 기법","키워드":"M 재 페 세\n역 T","도식":null,"정의":"MMU, Page Table 등 통해 가상 page 번호를 물리 번호로 변경한 뒤 Offset을 더하는 기법","내용":"기본 : MMU, 재배치 레지스터, Page table, Segment table\n- (문제) table 크기 너무 큼 \/ data 하나에 메모리 2번 접근\n> 향상 기법 : 역방향 Page Table, TLB(변환 색인 버퍼)"},{"토픽":"재배치 레지스터 변환 방식","키워드":null,"도식":null,"정의":null,"내용":"CPU가 전달한 논리주소 + 재배치 레지의 값 = 물리주소 값\nex) 346(논리주소) + 14000(레지 값) = 14346(물리주소)\n- 재배치의 덧셈 연산 소요시간을 2^k 의 배수로 제한\n- Mem 공간 연속 \/ 가상 주소의 합이 메모리 용량 초과 불가"},{"토픽":"Page Table 변환 방식 (직접 사상)","키워드":null,"도식":null,"정의":"Pid가 곧 인덱스인 배열에서 Pid에 해당하는 Fid를 찾아 주소 변환하는 방법","내용":"MM과 Disk를 page 단위로 분할 > page table 구축\n> CPU가 (p, d) 요청 > table의 p번째 값 찾아가면 F 있음\n> (f, d)로 물리 주소 찾음\n* 배열의 인덱스(주소)가 페이지 번호, 그 안의 값이 프레임"},{"토픽":"2단계 Page Table 변환 방식\n(Forward 매핑)","키워드":null,"도식":null,"정의":"여러 프로세스의 PT로 인한 메모리 비효율성 해결 위해 Page 번호를 10 bit 씩 나눠 필요부분만 메모리에 적재 기법","내용":"32bit 주소체계 + page가 4K byte > p 20bit, offset 12bit\n> p 20 bit > p1(디렉토리 주소 10 bit), p2(PT 주소 10 bit)\n> base + p1로 안쪽 PT 시작 주소 > 거기에 p2 더해 프레임\n> d값(offset) 더해 최종 MM 주소 알아냄"},{"토픽":"2단계 Page Table 변환 방식 한계","키워드":null,"도식":null,"정의":null,"내용":"컴퓨터가 32bit 아닌 64bit 주소체계일 시 p비트는 52bit\n> 2단계로 처리한다면 바깥 페이징이 42bit, 안쪽이 10 bit\n> 2^44 만큼의 page 공간이 필요, 너무 큼.\n> (32, 10, 10)로 3단계 PT, but MM 접근 4번 되어 속도 ↓"},{"토픽":"Segment Table 변환 방식","키워드":"S (리베) d","도식":null,"정의":"내부 단편화 해결 위해 Segmentation 할당 시, 가상주소를 물리주소로 변환 기법","내용":"CPU (s, d) 요청 > Seg Table의 s번째에 (Limit, Base)\n> [d < Limit] 이 맞으면 > (Base, d)가 물리주소\n* d > Limit 이면 그 프로그램의 할당 범위 넘어가니 에러!\n* Seg는 내부 단편화 해결하지만 페이징 기법 대비 느림"},{"토픽":"역 Page Table 변환 방식","키워드":null,"도식":null,"정의":"Fid가 곧 인덱스인 배열에서 Pid 값을 검색, 인덱스 값 찾아 프로세스 증가와 관계없이 PT 크기 고정되는 매핑 기법","내용":"PT 문제 : 그 Page가 MM에 있든 아니든 PT의 엔트리로 존재\n> Process 크기가 아닌 MM의 크기만큼만 PT 만들어 효율\n* 역 PT 문제는 PT 전체를 탐색해야 되는 것.\n> 해결법 : Associative Register 사용(but 비쌈)\n\n- 시스템에 하나의 페이지 테이블만 존재, 테이블 내 항목은 메모리 한 프레임씩 맵핑\n– 논리 주소는 Process-ID(pid), Page Number(p), Offset(d)으로 구성\n– 물리 주소는 메모리 프레임 번호(i)와 Offset(d)으로 구성"},{"토픽":"TLB 변환 방식\n(변환 색인 버퍼, 간접 사상)","키워드":"C T힛 M","도식":null,"정의":"가상 주소의 물리 주소 변환속도 향상 위해 TLB 캐시를 사용하는 기법","내용":"Hit : CPU > TLB Hit > 바로 MM의 data 접근\nMiss : CPU > TLB Miss > MM의 PT 접근 > MM의 data 접근\n* Paging 할당 시 쓰는 방법\n* TLB가 Associative Memory라서 연관(간접) 사상임"},{"토픽":"혼합 변환 방식 (직접\/간접 사상)","키워드":null,"도식":null,"정의":"Page Table을 MM이랑 TLB에 분산저장 후 가상 주소 물리 변환 기법","내용":"MM + TLB 혼합 \/ 주로 사용하는 기법\n* Paging 할당 시 쓰는 방법"},{"토픽":"CPU 명령어 인출 동작","키워드":"카 에 주데제 메 비 알","도식":null,"정의":"메모리에 저장된 명령어를 꺼내오는 과정","내용":"PC > MAR > 주데제 > 메 > MBR > IR"},{"토픽":"명령어 형식(구조)","키워드":"스 단 범","도식":null,"정의":"스택 구조(0), 단일누산기(1), 범용Register(2, 3) 등 Operand 개수 기반의 CPU 명령어 구조","내용":"0주소 : OpCode(Push, Pop 등) \/ 스택구조\n1주소 : Op코드, Operand(다른 대상은 AC, 결과 저장도 AC)\n2주소 : Op코드, Operand1, Operand2(결과 1에 저장)\n- 일반 PC, 태블릿, 스마트폰 등이 이거 해당\n3주소 : Op코드, Operand 1, 2, 3(2, 3 연산 결과 1에 저장)"},{"토픽":"CPU 주소 지정방식","키워드":"묵 즉 직 레 간 레 변\n변 코 레 옵","도식":null,"정의":"연산에 사용될 데이터를 기억장치의 어디에서 가져올지 Operand에 지정하는 방식","내용":"묵시(PUSH, POP 등 피연산자 X)\n즉치(ADD 24)\n직접(Operand에 주소)\n레지스터(레지 주소 씀)\n간접(MM 두 번 참조)\n간접레지(레지 두번 참조)\n변위(OpCode, Register, Offset)"},{"토픽":"CPU 변위(계산) 주소 지정방식","키워드":"상 베 인","도식":null,"정의":"직접주소+레지스터 간접 결합, 2개의 오퍼랜드 필드에 각각 레지스터와 변위값 넣어 유효주소 생성 방식","내용":"어느 레지스터를 사용하냐에 따라 나뉨\n- 상대 주소방식 : EA = (PC) + A(주소) \/ PC는 묵시 가능\n- Base Register 방식 : EA = Base + A\n- Index : EA = (IX) + A \/ IX는 명령실행시 자동↑(배열조작)"},{"토픽":"캐시 블록 사상","키워드":"직 연 집\n워 라 블","도식":null,"정의":"CPU의 명령어\/data 접근 속도 향상을 위해 MM에 저장된 일부 data를 캐시로 매핑하는 기법","내용":"Mem이 캐시보다 더 크니까 여러 Mem 블록이\n하나의 캐시 라인을 돌아가며 사용하게 됨\n> 메모리 블록을 캐시 내 어떻게 배치(매핑)할지 결정 필요\n* 4워드(주로 4~8) = 1라인(캐시 단위) = 1블록(MM 단위)\n\n직접사상 \/ 완전 연관 사상 \/ 집합 연관 사상"},{"토픽":"직접 사상 방식","키워드":"라 태 단","도식":null,"정의":"MM 블록들이 캐시 매핑 시 각각 지정된 라인으로만 적재 가능한 구조","내용":"data 주소의 라인필드 보고 캐시 데이터 라인 찾기\n> 선택 라인의 태그 비트랑 찾으려는 메모리의 태그 비교\n> 일치 시 단어 CPU 전송 \/ 불일치 시 miss, MM에서 인출\n* 블록별 매핑되는 캐시 라인 정해져 있어 간단하나 miss ↑"},{"토픽":"완전 연관 방식","키워드":"태 단","도식":null,"정의":"MM의 블록이 캐시의 어떤 라인으로든 적재 가능한 구조","내용":"캐시 라인별로 하나씩 태그번호 보며 태그필드랑 비교\n> 일치 시 단어 CPU에 전송 \/ 불일치면 miss, MM 인출, 캐시갱신\n* 캐시라인 일일이 살펴봐야, 캐시 miss 시 너무 비효율"},{"토픽":"집합 연관 방식","키워드":"태 세 단","도식":null,"정의":"캐시를 여러 세트로 나눠 MM의 블록이 캐시 내 지정된 한 세트로만 적재 가능한 방식","내용":"캐시의 세트 번호 보고 그 집합 선택\n> 집합 내에서 라인 하나씩 보며 맞는 태그 있나 봄\n - 일치 시 캐시 hit\n - 불일치 시 캐시 miss"},{"토픽":"캐시 메모리 변경(Write) 정책","키워드":"Write Through(VI)\nWrite Back(MESI)","도식":null,"정의":"캐시 블록이 변경되었을 때 그 내용을 MM에 갱신하는 시기와 방법의 결정 정책","내용":"스누피 prtcl 로 캐시 변경 확인\nWrite through : 캐시\/MM 동시 Write, Valid면 캐시==MM\nWrite Back : 캐시가 Swap out 할 때 MM에 해당 data 복사\n- MESI(Modified, Exclusive, Shared, Invalid)"},{"토픽":"Write Back 기법","키워드":"클 업 디 플 초 븨","도식":null,"정의":"캐시 Write Back 시 캐시와 메인 메모리 간 일관성 유지 기법","내용":"Cache Clean : Cache 내 data를 메모리에 업뎃\n- 클린하면 D bit이 0 됨 \/ DMA 등 I\/O 사용 시 Mem 현행화\nCache Flush : Cache 내 data를 0으로 변경해 초기화\n- V bit이 0 됨 \/ 캐시에서만 사용하는 일회성 Data"},{"토픽":"Cache Bit","키워드":"더 일 밸 로","도식":null,"정의":null,"내용":"D(dirty Bit) : 0이면 캐시와 Mem 내용 일치 \/ 1이면 불일치\nV(valid Bit) : 0이면 Data가 Mem에서 캐시로 Load 안됐음\n- 1이면 Data가 Mem에서 캐시로 Load 됨\n\n"},{"토픽":"캐시 메모리 일관성 유지 기법","키워드":"하 디 스\n소 공 변","도식":null,"정의":"다중 프로세서 환경에서 각 캐시 간의 데이터를 일치시키는 기법","내용":"HW\n디렉토리 prtcl 기반(캐기 블록 공유 상태 디렉토리에 저장)\n– Full map: 중앙집중식, 복사본 포인터\n– Limited: Fullmap 작게 유지, 메모리 효율화\n– Chained: 포인터를 Linked-list로 연결\n\n스누프 제어기(Bus 감시 중 타 캐시가 쓰면 자기 무효 = VI, MESI)\n– Write Through \/ Write Back: 캐시 수정 → 메모리 갱신X\n\nSW : 공유 캐시(모든 CPU가 하나의 캐시 공유),\n공유변수는 캐시 미사용(수정 가능한 data는 MM에만 저장)"},{"토픽":"VI","키워드":null,"도식":null,"정의":"프로세서가 캐시 데이터 수정 시 주기억장치로 갱신하는 Write Through 기반 일관성 유지 기법","내용":"캐시상태\nV: Valid > 캐시 내용 = 주기억장치 내용\nI: Invalid > 캐시 내용 != 주기억장치 내용"},{"토픽":"Mesi","키워드":"수 배 공 무","도식":null,"정의":"변경된 캐시 스누피 제어기가 다른 스누피 제어기에게 변경된 내용 통보하는 write-back 기반 일관성 유지 기법","내용":"MESI프로토콜\n수정(Modified): 데이터가 수정(변경)된 상태\n배타(Exclusive): 유일한 복사복, 주기억장치와 동일 상태\n공유(Shared): 데이터가 2개 이상 프로세서 캐시 공유\n무효(Invalid): 데이터가 다른 프로세서의 수정으로 무효"},{"토픽":"입출력 제어 방식","키워드":"프 인 디 채","도식":null,"정의":null,"내용":"프로그램에 의한 I\/O(PIO, CPU 개입)\n인터럽트에 의한 I\/O(CPU 개입)\nDMA에 의한 I\/O(CPU 개입 X)\n채널에 의한 I\/O(CPU 개입 X, 대형 서버에 많이 사용)"},{"토픽":"PIO\n(Programmed Input\/Output)","키워드":null,"도식":null,"정의":"NW 어댑터, ATA 저장소 등 주변 기기 및 MM 간의 data 전송 시 무조건 CPU를 거치는 방식","내용":"Directed I\/O : Data 전송 시까지 CPU가 다른 작업 못함"},{"토픽":"DMA\n(Direct Memory Access)","키워드":"씨 버 그 전 인","도식":null,"정의":"하드디스크, 그래픽 카드 등의 I\/O 장치와 MM 간에 CPU의 개입 없이 data를 전송하는 방식","내용":"CPU 명령 > Bus Request > Bus Grant > 전송 > 인터럽트 \nData 전송 완료 시에만 CPU에 인터럽트 딱 1번 발생\n- CPU는 전송 시작\/끝에만 관여, 전송 중엔 다른 작업 수행\n- But, 캐시 일관성 문제 일어날 수 있음"},{"토픽":"DMA 동작 모드","키워드":"사 버 투","도식":null,"정의":null,"내용":"Cycle 스틸링 : CPU가 DMA에 bus 양보해 빠른 I\/O 처리\n- DMA 동작 1번에 한 워드 전송, 프로그램 상태 보존 필요 X\n* 인터럽트는 I\/O 처리 내내 CPU 정지, 상태 보존 필요\n버스트 모드 : DMA가 bus 획득 시 전송 완료까지 cycle 독점\n- 블록(여러 워드) 단위로 data 전송, 고속 I\/O 장치 대상\n투명 모드 : CPU가 bus 미사용 할때만 DMA가 data 전송\n- CPU가 안 멈춤, but 버스 사용 여부 봐야해서 HW가 복잡"},{"토픽":"DMA 컨트롤러","키워드":"카 레 주 컨","도식":null,"정의":null,"내용":"Source\/Destination Address 레지 : 출발\/목적지 주소\nWord count 레지 : 전송할 블록의 Word 수\n- 매 워드 전송될 때마다 H\/W에 의해 감소됨, 0 여부 점검\nControl 레지 : 동작 모드 설정, CPU 명령 받고 인터럽 줌"},{"토픽":"채널에 의한 I\/O","키워드":null,"도식":null,"정의":"DMA 개념을 확장한, I\/O만을 위한 전용처리장치인 입출력 채널로 CPU 개입 없이 I\/O 하는 방식","내용":"DMA 개념을 확장한, I\/O만을 위한 전용처리장치\nCPU처럼 독자적으로 MM에 저장된 명령어 처리 가능\nDMA와 달리 한 개 명령에 여러 블록 입출력 가능"},{"토픽":"입출력 속도 개선(동기화) 방법","키워드":"버 하 메\n스 소 디","도식":null,"정의":"고속의 CPU와 저속의 I\/O 장치 간 처리 속도 차이를 줄이기 위한 기법","내용":"버퍼링 : HW 기법(MM 내 버퍼)\n스풀링 : SW 기법(Disk 내 I\/O 작업 Pool, OS 내 스풀러)"},{"토픽":"버퍼링","키워드":null,"도식":null,"정의":"메인 메모리 일부를 버퍼로 사용하여 CPU와 I\/O 간 전송 속도 동기화 기법","내용":"한 프로세스의 I\/O와 연산을 동시 처리 시에 효율적\n버퍼에 각 I\/O 스트림 저장 > 이벤트(출력 누름) 시 각각 출력\n* 프린터 인쇄 누르면 내용 다 전송 후 한번에 출력하는 그거."},{"토픽":"버퍼링의 종류","키워드":"단 이 환","도식":null,"정의":null,"내용":"단일 : 버퍼 1개(병렬 불가), All or Nothing\n이중 : 버퍼 2개 독립 운영(2개 I\/O 병렬 가능), CPU 효율성\n환형 : 버퍼 큐(3개 이상), CPU 독립성 \/ 버퍼 多시 공간 낭비\n* CPU bound 프로세스(연산 多)는 버퍼↓, I\/O bound면 ↑"},{"토픽":"스풀링","키워드":null,"도식":null,"정의":"Disk 등 외부 물리저장소에 작업 pool 공간을 할당해 여러 I\/O 작업 병렬 실행하여 CPU와 I\/O 속도 동기화 기법","내용":"여러 프로세스를 동시 작업할 시 효율적(버퍼링 보다 효율적)\n여러 I\/O 장치의 작업 각각 Pool에 저장 > 병렬 처리"},{"토픽":"메모리 인터리빙","키워드":"상 모 주 C\n하 주 모 S\n혼 뱅 모","도식":null,"정의":"MM 접근 빠르게 하기 위해 인접한 메모리 위치를 서로 다른 메모리 bank에 둬 동시에 여러 곳 접근 기술","내용":"상위 : 상위bit는 모듈, 하위는 주소, SPOF 없음, C-Access\n하위 : 상위bit는 주소, 하위가 모듈, SPOF 발생, S-Access\n혼합 : 상위bit는 뱅크, 하위는 모듈(그룹 내 하위 인터리빙)\nC-접근은 순차 Data read, S는 주소 다 도착하면 동시 read"},{"토픽":"CPU 스케줄링 알고리즘","키워드":"비 우 기 S F H\nHRN 대기는 서서\n선 R S 다큐 다피","도식":null,"정의":"OS가 Ready Queue에 있는 어떤 프로세스에 CPU를 할당 할 것인지 결정하는 알고리즘","내용":"비선점 : 우선순위, 기한부, SJF, FCFS, HRN(대기+서비스 시간 \/ 서비스 시간, SJF의 기아문제 해결)\n선점 : RR, SRT(숏 Remaining), MLQ, MLFQ\nMLQ는 큐별로 이동 불가 \/ MLFQ는 밑 큐로 계속 내려감"},{"토픽":"CPU 스케줄링 평가 기준","키워드":"응 반 대 실 처\n응 도 시\n반 도 완","도식":null,"정의":null,"내용":"응답시간 : 프로세스 도착 ~ 첫 시작\n반환시간 : 프로세스 도착 ~ 완료\n대기시간 : 프로세스 도착 이후 대기한 모든 시간 합\n프로세스 실행율(유휴 아닌 비율)\n처리율(시간 당 처리 수)"},{"토픽":"호위효과\n(Convoy Effect)","키워드":"잡 하 데 우","도식":null,"정의":"선 실행 프로세스의 CPU burst 시간이 매우 길면, 그 다음 도착한 프로세스가 엄청 오래 기다리는 문제 현상","내용":"FCFS 등에서 생기는 문제\n해결 : SJF, HRN, Deadline 설정, 프로세스별 우선순위 부여"},{"토픽":"에이징","키워드":"하 멀피","도식":null,"정의":"오래 대기한 프로세스에 대해 Priority 높여서 처리 보장하는 CPU 스케줄링 기법","내용":"SJF에 에이징 추가 > HRN\nMLQ에 에이징 추가 > MLFQ\n- MLQ : 큐별 우선순위, 각자 독자적 스케줄링, 큐 간 이동 X\n- MLFQ : 큐별로 RR, 내려갈수록 순위↓ & Time Slice↑ "},{"토픽":"실시간 스케줄링","키워드":"경 R E\n연 선 우 지","도식":null,"정의":"실시간 운영체제(RTOS)에서 Deadline 내 프로세싱을 보장 위한 스케줄링 기법","내용":"경성 : RM, EDF\n연성 : 선점형, 우선순위, 지연시간 최소화\n실시간 처리를 보장하는게 X, 실시간 처리 불가한 작업 거부\nCPU 이용률 = 프로세스별 (실행시간 \/ 주기) 계산해 더함"},{"토픽":"연성, 경성 시스템 차이점","키워드":null,"도식":null,"정의":null,"내용":"연성 : Deadline 놓치면 손해는 생기지만 완전한 실패는 아님\n- DVD 플레이어 : 조금 끊긴다고 해서 치명적 결과는 아님\n경성 : Deadline 놓치면 치명적, 마감 초과한 결과는 노쓸모\n- 미사일 격추, 항공\/우주"},{"토픽":"RM\n(Rate Monotonic, 주기단조 스케줄링)","키워드":"82.8% 77.9% 69%","도식":null,"정의":"개별 프로세스 주기를 기준으로 주기 짧을수록 높은 우선 순위 부여하는 정적 스케줄링 기법","내용":"우선순위 고정이라 스케줄링 오버헤드가 낮음\nBut CPU 이용률 떨어지고, 경성 만족을 못해(연성은 만족)\nCPU 이용률 ≤ N * [2^(1\/N) - 1]\n- 프로세스 개수별 100%, 82.8%, 77.9% .. 69%까지 떨어짐"},{"토픽":"EDF\n(Earliest Deadline First)","키워드":null,"도식":null,"정의":"임의의 실행 시점에서 가장 마감시간 가까운 작업에게 높은 우선순위를 할당하는 동적 스케줄링 기법","내용":"프로세스 주기적일 필요 없고, CPU할당도 제한 없음\nBut 오버헤드 높음, task 수행\/마감시간, 주기 예측 힘듦\nCPU 이용률 ≤ 1 (이론상 100%)\n- But 실제론 문맥교환 땜에 어려움"},{"토픽":"우선순위 역전 해결법","키워드":"상 올","도식":null,"정의":"실시간 스케줄링 시 문제로 낮은 순위 Task가 임계영역 Lock 하여 높은 Task가 수행 못하는 현상","내용":"상속 : 우선순위 낮은 T3을 T1 순위만큼 올려서 먼저 실행\n올림 : 세마포어 소유 시 지정된 우선순위만큼 올려 실행\n* T3가 낮지만 먼저 실행해서 세마포어 가졌을 때의 얘기임"},{"토픽":"Race Condition","키워드":"톡 일 데 라 보","도식":null,"정의":"여러 프로세스가 임계영역 내 공유자원 동시 접근 시, 접근 순서 따라 결과가 달라 데이터 일관성문제 가능한 상태","내용":"동시성 이슈 : TOCTOU, 일관성 문제\nStarvation : Deadlock, Livelock\n보안 이슈 : Race condition Attack"},{"토픽":"Race Condition 해결방법","키워드":"소 데 피 램\n하 테 스\n동 세 모 뮤 스","도식":null,"정의":null,"내용":"SW : 데커(Dekker), 피터슨, 램포트\nHW : Test and Set, SWAP\n동기화 : 세마포어, 모니터, 뮤택스, 스핀락"},{"토픽":"Race Condition SW 해결방법","키워드":"데 플 턴\n피 양\n램 번","도식":null,"정의":null,"내용":"데커 : flag(나 들어갈거야), turn(누가 진입 차례인지)\n- 2개 중 누가 임계영역 먼저 진입하나 \/ 최초 상호배제 보장\n피터슨 : 데커랑 비슷하나 간단, 임계영역 기회 양보 후 진입\n램포트 : N개의 상호배제 \/ 고유 번호 부여, 낮은 번호 먼저"},{"토픽":"데커 알고리즘","키워드":"삐 플 턴 검","도식":null,"정의":"turn 값이 A면 A가, B면 B가 진입함","내용":"A 프로세스 동작 원할 시\n- flag[A] = T; 설정 후 > flag[B] 값 검사\n- flag[B] = T면 turn 값 검사 > turn = B면 A는 대기\n- A 종료 후 flag[A] = F;  turn = B 설정"},{"토픽":"피터슨 알고리즘","키워드":"삐 턴 설 플 검","도식":null,"정의":"데커 알고리즘보다 구현 간단 turn이 A면 B가, B면 A가 진입함","내용":"A 프로세스 동작 원할 시\n- flag[A] = T;  turn = B; 설정  \/\/ B에 기회를 양보\n- flag[B] 검사 > T면 B가 먼저 동작, F면 A가 바로 진입\n- A 종료 후 flag[A] = F;"},{"토픽":"Race Condition HW 해결방법","키워드":"테 락\n스 교","도식":null,"정의":null,"내용":"Test and Set : 임계영역 진입 시 Lock \/ 종료 시 해제\n- Test and Set(Lock) > Lock = 0\nSWAP 명령 : HW 상 두 메모리 워드 간 내용의 원자적 교환\n- Boolean *a(전역변수), Boolean *b(지역변수) 간 교환"},{"토픽":"동기화","키워드":null,"도식":null,"정의":"레이스 컨디션에서, 상호배제 조건 등을 통해 자원의 일관성을 유지하는 기법","내용":"세마포어, 모니터, 뮤택스, 스핀락\n> 그러나 이를 통해 오히려 데드락 등 발생 가능"},{"토픽":"세마포어","키워드":"S P C V","도식":null,"정의":"멀티프로그래밍 환경에서 정적 변수를 사용하여 공유자원 접근을 제한하는 OS 수준의 low level 기법","내용":"Semaphore(n);  P();  Critical Section  V();\nP연산(Wait) : If S > 0 then S--;  Else block();\nV연산(Signal) : S++;  wake_up();\n* 세마포어 수(n)는 CS에 들어갈 공유변수의 개수"},{"토픽":"모니터","키워드":"배 씨 조\n싱배 웨조 시임\n\n싱 웨 노 올","도식":null,"정의":"세마포어의 단점인 타이밍 문제 해결을 위해 프로그래밍 언어 수준의 동기화 수행 high level 기법","내용":"배타동기큐 > CS(임계영역) 진입 > 조건동기 큐(Block)\n* 쓰레드는 모니터랑 통신해 CS 진입 요청, 처리결과 받음\nSynchronized : 배동큐 \/ Wait : CS에서 조동큐로(block)\nSignal, Notify : 조동큐에 있는 쓰레드를 깨워 임계 재진입\n\n배타동기: synchronized 키워드 사용하여 지정\n조건동기\n조건동기 큐 in : wait()\n조건동기 큐 out : notify(), notifyAll() 메소드 사용"},{"토픽":"뮤택스","키워드":"자 락 선","도식":null,"정의":"세마포어의 자원이 1개일 시. Lock과 Unlock으로 공유자원에 대한 쓰레드의 접근 제어","내용":"\"준비되면 깨워주세요\" 하고 Wait 전환\n공유자원(변수)가 Lock인지 아닌지만 바라봄\n- 다른 Task가 안끝났어도 변수만 Unlock 하면 바로 점유\n> 프로세스 선점 가능, 문맥 전환 있음"},{"토픽":"스핀락","키워드":"태 끝 비","도식":null,"정의":"프로세스가 Lock 획득 때까지 명령어 루프를 돌며 계속 시도하는 Busy Waiting 기법","내용":"명령어 정리하기\n공유변수가 아닌 Task만 바라봄\n- 다른 Task 끝날 때만 자원을 가져옴\n> ∴ 문맥 전환 없음, 비선점"},{"토픽":"데드락","키워드":"발생 조건 : 상 점 비 환\n해결법 : 예 회 발 복\n회 뱅 웨 운\n복 중 선 \/ 발 자 타","도식":null,"정의":"두 개 이상의 작업이 상호 자원을 점유하기 위해 무한 대기중인 상태","내용":"발생조건\n상호배제, 점유와 대기, 비선점, 환형대기\n\n예방 : 상점비환 예방 > 자원낭비 증가, 기아 발생 가능\n회피 : Banker's 알고리즘, Wait-Die, Wound-Wait\n발견 : 자원할당 그래프, 타임아웃(미작업 프로세스는 교착)\n회복 : 프로세스 중지, 자원 선점"},{"토픽":"Banker's Algorithm","키워드":"어 맥 얼 니\nM A N A","도식":null,"정의":"프로세스가 자원을 요구할 때 자원 할당 후 안정 상태인지 사전 검사한 뒤 할당하는 교착상태 회피 기법","내용":"안정 : 자원 할당, 불안정 : 요청 대기\nMax(최대 요구 자원)\nAvailable\nNeed(Max - Allocation)\nAllocation(할당된 자원)\n\n문제 : 자원 요구량 미리 알아야, 은행원 병목, 자원 이용률↓"},{"토픽":"Wait-Die","키워드":"고 기 신 다","도식":null,"정의":"다른 프로세스가 데이터 점유시 기다리거나(wait) 포기(die)하는 비선점 기법","내용":"먼저 들어 온 프로세스는 wait, 후순위는 die\n중지된 프로세스는 기존 타임 스탬프를 가지고 재시작하여,\n무한정 대기 방지(Starvation 해결)\n구현이나 관리 쉬우나, 프로세스 재수행 땜에 성능 저하 가능\n\n고참은 기다리고 신참은 다이"},{"토픽":"Wound-Wait","키워드":"고 다 신 기","도식":null,"정의":"다른 프로세스가 데이터 점유시 선점(wound)하거나 기다리는(wait) 선점 기법","내용":"선 순위는 wound, 후순위는 wait\n\n고참은 다이 신참은 기다림"},{"토픽":"Livelock","키워드":"양 반 소 백 킬","도식":null,"정의":"데드락 회피하려 수정한 코드가 불완전할 때 발생하는, 두 프로세스가 lock 해제, 획득 무한 반복하는 상태 ","내용":"골목에서 A랑 B가 서로 같은 방향으로 피해서 둘 다 못지나감\n상호양보, 락 해제\/획득 반복(무한 동작), 자원 소모&대기\n- 데드락 : 상호 자원 요구, 무한 대기, 자원 소모 없음\nTry and back off, Process kill 등으로 해결"},{"토픽":"프로세스","키워드":"생 준 실 대 종\n디 타 콜 웨","도식":null,"정의":"메모리에 적재되어 OS 제어 하에 실행 중인 프로그램","내용":"활동상태(5개) : 생성 > 준비 > 실행 > 대기 > 종료\n- Dispatch, Timeout, Block(Sys call, I\/O), Wakeup\n7개 : '활동상태' 밑에 '지연상태' 추가(지연 준비, 지연 대기)\n* 준비, 대기에서 swap out 하면 지준, 지대\n* 지연 대기가 wake up 하면 지연 준비"},{"토픽":"PCB\n(Process Control Block)","키워드":"피 상 카 스 시 입 메","도식":null,"정의":"OS가 프로그램 실행을 위해 프로세스 정보를 담고 있는 자료구조","내용":"PID, 상태(생준실대종), 프로그램 카운터(다음 명령 주소)\n스케줄링 정보(우선순위 등), 사용시간, 입출력 상태 정보,\n메모리 관리 정보(Base, Limit 등)"},{"토픽":"TCB\n(Thread Control Block)","키워드":"티 상 카 레","도식":null,"정의":null,"내용":"TID, 상태, 프로그램 카운터, 레지스터"},{"토픽":"프로세스 생성","키워드":"포 피 피 초 링","도식":null,"정의":"OS 또는 다른 사용자의 APP 요청에 의해 생성","내용":"부모가 fork()로 자식 만듦 > PID 할당 > PCB 할당\n> PCB 초기화 > 링크(해당 큐에 삽입)"},{"토픽":"프로세스 종료","키워드":"마 익 삭","도식":null,"정의":"프로세스가 마지막 문장 실행을 끝내고, exit() 시스템 호출로 OS에게 삭제 요청하여 종료","내용":"마지막 문장 실행 > exit() > OS가 삭제"},{"토픽":"IPC\n(Inter Process Communication)","키워드":"큐 공 세 파 네 소 시","도식":null,"정의":"독립 프로세스들 사이에 자원, 정보공유 및 교환 등 위해 서로 데이터를 주고 받는 행위","내용":"메세지 큐(커널 내 큐)\n공유 메모리\n세마포어\n파이프(pipe로 부모\/자식 단방향, FIFO, 양방향은 R\/W 각각)\nNamed Pipe(아무 프로세스 간 단방향 통신, 양방향 할거면 R\/W pipe 각각 생성)\n소켓\n시그널"},{"토픽":"프로세스와 스레드 차이","키워드":"생 통 병 스","도식":null,"정의":null,"내용":"생성 - P : OS가 생성 \/ T :프로세스가 생성\n상호통신 - P : 큐 공 세 파 네 소 시 \/ T : P의 힙 메모리, 큐\n병렬화 - P : 부모가 자식 fork() \/ T : 메인이 워커 create()\n스케줄링 - P : 커널(시스템) 레벨 \/ T : 유저(Library) 레벨"},{"토픽":"문맥","키워드":"시 메 하","도식":null,"정의":"문맥교환 발생 시, 이전 프로세스 상태를 재현할 수 있게 지원하는 정보","내용":"시스템 문맥 : Task 정보, 프로세스 자원정보(PCB 정보)\n메모리 문맥 : 프로세스에 할당된 메모리 정보(텍 데 스 힙)\n하드웨어 문맥 : Task 실행 위치(Process 카운터, HW 레지)"},{"토픽":"문맥 교환","키워드":"실 콜 저 적\n다 쓰 타 포","도식":null,"정의":"CPU 사용중인 프로세스의 CPU 제어권이 타 프로세스로 이양되는 과정","내용":"P0 실행 > Interrupt\/System call > OS는 P0 문맥을\nPCB0 저장, P1 문맥 적재 > P1 실행 > Sys call > OS > P0\n\n문맥 교환 오버헤드 : 다중 프로그래밍 낮춤, Thread 활용,\n적절한 Time Slice 유지, 스택 포인터 활용"},{"토픽":"문맥교환 발생 시점","키워드":"준 실 디\n실 준 타\n실 대 콜","도식":null,"정의":null,"내용":"1. 준비 > 실행(Dispatch)\n2. 실행 > 준비(time slice 만료)\n3. 실행 > 대기(I\/O 작업, System Call)"},{"토픽":"CPU Scheduler","키워드":"장 단 중","도식":null,"정의":" OS에서 다중 프로그램을 지원하기 위해 프로세스들을 효율적으로 CPU에 할당하는 역할을 수행하는 운영체제 커널의 모듈","내용":"장기 스케줄러\n어떤 프로세스를 ready queue에 넣을지 결정\n과거 메모리 부족으로 사용 \/ 현대 디스크>메모리로 바로 올림\n\n단기 스케줄러\n스케줄링 알고리즘을 통해 ready 상태 프로세스 running 상태 할당\nms 이하의 시간 단위 \/ 수행 속도가 매우 빠름\n\n중기 스케줄러\n메모리에 적재된 프로세스의 수를 조절하는 역할 수행(성능저하 예방)\n메모리 영역을 디스크의 swap 영역으로 옮기는 swap out 발생"},{"토픽":"Dispatcher","키워드":"문 상 재","도식":null,"정의":"단기 스케줄러가 선택한 프로세스에 실제로 CPU 할당해 프로세스 문맥을 전환하는 운영체제 내부 모듈","내용":"프로세스의 레지스터를 적재(문맥교환)\n운영체제 모드(Kernel Mode)에서 사용자 상태(User Mode)로 전환\n프로세스가 재시작시 사용자 프로그램이 올바른 위치를 찾게 처리"},{"토픽":"제로 카피","키워드":null,"도식":null,"정의":"NW data 전송 시 문맥교환 최소화 위해 커널 > 유저모드로 copy 없이 바로 소켓버퍼로 copy 기법","내용":" sendfile() 시스템 콜이 제로카피(Zero-copy) 동작을 구현\n\n기존에는 User 모드의 Application Buffer 존재하여 복사했다가 다시 Kernel모드 진입\n\n카프카가 빠른 이유"},{"토픽":"스레드","키워드":"데 파 공 \/ 레 스 코 따\n메 워 \/ 커 유","도식":null,"정의":"프로세스 내부에 존재하는 일련의 실행 코드로 독립된 CPU 작업의 최소 단위(Lightweight Process)","내용":"프로세스 Data, File 공유 \/ Register, Stack, Code 따로\n구성 : 메인(실제 코드 수행) \/ 워커(메인이 생성, 백그라운드) \n- 메인은 짧고 핵심 작업, 워커는 오래 걸리는 작업\n종류 : 커널 \/ 유저(스레드 library 이용, 유저레벨에서 관리)"},{"토픽":"커널 스레드","키워드":null,"도식":null,"정의":"OS에서 구현되며 커널이 생성 및 스케줄링 관리하는 스레드","내용":"동작 중인 스레드가 System Call(커널 호출)해도\n해당 프로세스 내 다른 스레드가 계속 실행될 수 있음\n스케줄링과 동기화를 위해 System Call 하는데 오래 걸림\n유저모드와 커널모드 간 전환이 빈번하여 성능 저하\n\nTCB가 커널 영역에 존재"},{"토픽":"유저 스레드","키워드":null,"도식":null,"정의":"#include 등을 통해 스레드 기능 제공 library 활용, 커널 진입 안해도 유저 영역에서 수행되는 스레드","내용":"OS는 프로세스 내 여러 스레드 있는걸 몰라 프로세스 하나로\n인식 > 스레드 하나 중단 시 같은 P 내 모든 스레드 중단\n동일 메모리 영역에서 스레드가 생성, 관리되므로 속도 빠름\n커널이 스레드 존재를 몰라서 유저\/커널모드 간 전환 없음\n\nTCB가 유저 영역에 존재"},{"토픽":"멀티 스레드 모델","키워드":"매 원\n원 원\n매 매\n(유-커)","도식":null,"정의":"프로세스와 자원을 공유하며 여러 스레드 간 독립적 수행 공간 할당","내용":"Many to One : 여러 개의 User 스레드 - 커널 스레드 1개\nOne to One : User 스레드별 커널 스레드 각각 매핑(병렬)\nMany to Many : User 스레드(n개) - 커널 스레드(n개 이하)\n커널 스레드 만들라면 프로세스 생성해야 돼서 상황보고 go"},{"토픽":"멀티 스레드 종류","키워드":"인 블 동 칩","도식":null,"정의":null,"내용":"Interleaved(Fine-grain) : Clock cycle 마다 스레드 스위칭\nBlocked(Coarse-grain) : 캐시 미스 등 사건 발생 시 스위칭\n동시 멀티스레딩(SMT) : 수퍼스칼라 CPU, 다수 명령어 동시\nChip멀티프로세싱 : 수퍼스칼라 + 프로세스마다 명령어 2개"},{"토픽":"인터럽트","키워드":"하 전 기 타 입\n소 오 제 콜","도식":null,"정의":"멀티 프로세스 처리 및 응급 상황 대응 위해 실행 중인 작업 즉시 중단 후 상황 처리하도록 하는 신호","내용":"HW : CPU가 아닌 다른 HW 장치가 CPU에 알림\/요청 시\n- 전원 꺼짐, 기계 오류, 타이머 종료, 입출력 종료\/오류\n\nSW : 사용자 프로그램이 스스로 세팅해 둔 인터럽트 line\n- 오버플로우, Divide by Zero, System Call"},{"토픽":"인터럽트 처리 분류","키워드":"마 논마\n벡 폴","도식":null,"정의":null,"내용":"Maskable : 무시 가능한 인터럽트, vector\/polling 다 가능\nNon-Maskable : 무조건 바로, vector 처리\n조사 방식 : Vector(HW 방식), Polling(SW 방식)"},{"토픽":"벡터 인터럽트","키워드":"검 금 저 처 적 허","도식":null,"정의":"CPU랑 인터럽트 요청 장치 사이에 버스를 연결해 장치번호를 CPU에 알리는 HW적 방식","내용":"유형 : Daisy Chain(순차, 직렬 연결) \/ 병렬 연결 방식\n(유저)인터럽트 > (커널) IVT 조회, ISR 검색, ISR 찾아감\n> (ISR)인터럽트 금지, PCB 저장, 인터럽트 처리, PCB 적재,  인터럽트 허용, ISR 종료 > (유저)프로세스 실행"},{"토픽":"인터럽트 우선순위 부여방식","키워드":"직 병 폴","도식":null,"정의":null,"내용":"직렬(Daisy Chain) : 최고 순위 > 낮은 장치로 HW 회로 직렬\n병렬 : 인터럽트 회선 여러 개, 현재 intrpt보다 높으면 걔 먼저\n폴링 : intrpt 시 최고 순위부터 요청 flag 검사해 누군지 찾음\n* HW : 직 병 \/ SW : 폴"},{"토픽":"인터럽트 처리 절차","키워드":"검 금 저 처 적 허","도식":null,"정의":null,"내용":null},{"토픽":"파이프라인","키워드":"IF ID EX MEM WB","도식":null,"정의":"명령어 사이클 각 단계를 중첩, 전체 프로그램 수행 시간 단축, 명령어 처리율 향상시키는 기법","내용":"IF, ID, EX, MEM, WB 중 1번이 ID할 때 2번 IF 병렬 실행\n명령어 처리 시간 측정 : T = step*t + (n-1)*t\nstep은 명령어 당 단계, t는 단계당 처리 시간, n은 명령어 수"},{"토픽":"비파이프라인","키워드":null,"도식":null,"정의":"하나의 명령어가 다 끝난 후 다음 명령어 실행","내용":"명령어 처리 시간 : T = step * t * n"},{"토픽":"파이프 해저드","키워드":"구 데 제","도식":null,"정의":"파이프라인 프로세서에서 명령어 의존성(구데제) 발생시킬 수 있는 문제","내용":"구조적 : HW 제한(동시에 Mem 접근 등) \/ 캐시, 시분할 등\n데이터 : RAW(R after W), WAW, WAR \/ bypass(결과를\n저장 전에 바로 써버리자), 명령어를 해저드 없게 재배치\n제어 : 분기 명령 \/ Predict-Not-Taken, Branch 타겟 버퍼"},{"토픽":"병렬처리시스템 기반 상호연결망","키워드":"정 토 스 완 선 큐 링 매 트\n동 버 크 다","도식":null,"정의":"여러 처리요소를 가진 병렬처리시스템에서 처리요소들과 기억장치들 사이를 연결해 주는 네트워크","내용":"정적 : 시스템 요소 간 직접 연결된 경로, 연결 구조 고정\n- 토러스, Star, 완전 연결형, 선, 큐브 NW, 링, 매쉬, 트리\n동적 : 시스템 요소 간 연결 경로가 실행 시간 동안 변경 가능\n- 버스, 크로스바, 다단계 네트워크"},{"토픽":"토러스 구조","키워드":null,"도식":null,"정의":"병렬처리시스템에서 같은 행, 열에 위치한 노드들이 원형으로 연결되는 매쉬구조","내용":"선형 구조처럼 끝과 끝을 이어서 대칭성 부여\n> 평균 통신거리 줄임(NW 홉 수 절반) > 성능 향상\nn x n 토러스의 경우 네트워크 지름 = n"},{"토픽":"RAID","키워드":"하 펌 소","도식":null,"정의":"여러 저렴한 디스크 집합으로 data 접근 속도나 안정성 향상 저장장치 기술","내용":"HW 방식 : 별도 물리 장치인 RAID 카드 이용해 구현\n- OS 진입 전, 카드 설정에서 관리(OS는 Disk 하나로 인식)\n\n펌웨어 : RAID 카드보다 간소화한 RAID칩을 메인보드 탑재\n- 펌웨어(드라이버)로 구현(OS 전 BIOS에서 RAID 구성)\n\nSW : OS가 인식하는 저장장치 통해 구성\n- 메인보드 변경 시 RAID 유지되나 OS 변경 시 유지 불가\n* But 윈도우의 [Disk 가져오기 기능] 사용 시 유지 가능"},{"토픽":"RAID 종류","키워드":"스 미 비이 바페 블페 분 다","도식":null,"정의":"Frame 좀 날라가도 되는 영상 등은 RAID 0 사용","내용":"0 : Block Striping \/ A는 Disk 1, B는 Disk 2 \/ 성능↑ 신뢰↓\n1 : 미러링 \/ 1, 2번 똑같은거 복붙 \/ 신뢰 굿, 성능 낮음\n2 : Bit Striping(블럭을 쪼개서 저장) + ECC(에러 정정 코드)\n- Data 4개, ECC 3개(3 bit)면 7개 중 3개(ECC 수)까지 복구\n3 : Byte Striping + Parity Disk 1개(Disk 1개까지 복구)\n4 : Block Striping + Parity Disk 1개\n* 3, 4는 Data W시 Parity도 W > W 중첩 불가, R 중첩 가능\n5 : Parity 분산(Disk별 P) > W 중첩 가능, P Disk 부하↓\n6 : Parity 다중화(P 2개씩) > 2개 HDD 장애도 복구\n0+1 : (1 3 5) + (2 4 6)을 2개 둠 \/ 1+0을 더 많이 씀"},{"토픽":"Erasure Coding\n이레이저 코딩","키워드":"N 인 디","도식":null,"정의":"데이터 손실 시 인코딩된 데이터의 디코딩 과정을 통해 원본 데이터를 복구하는 스토리지 데이터 복구 기법","내용":"Data N등분 > k개 인코딩 > N+k개 > Decoding 시 복구\n- k개까지 손실 돼도 복구 가능(복구일 뿐, 백업은 아님)\n- RAID는 P용량 고정, Erasure은 P 개수 직접 지정해 절약\nRAID : 단일 Storage Array \/ Erasure : HCI 등 분산 Storage"},{"토픽":"FTS\n(Fault Tolerant System)","키워드":"탐 진 통 복","도식":null,"정의":"HW나 SW의 결함, 오동작, 오류 시에도 기능 지속 수행 가능한 시스템","내용":"결함탐지 > 결함진단 > 결함통제 > 결함복구\n탐지 : Fault 발생 모듈은 Fault 상태 진입, Fault 한 애 분석\n진단 : 영구적 fault면 모듈 제거, 일시적이면 계속 수행 판단\n통제\/복구 : 오류 파급 차단\/격리, fault 유발 모듈 제거\/교체"},{"토픽":"FTS HW 기술","키워드":"듀 트 리 워","도식":null,"정의":null,"내용":"Duplication with Comparison : HW 중복 후 비교해 감지\nTMR(Triple Modular Redundancy) : 3개 이상 모듈 다수결\n- 같은 입력에 대해 동일 연산 수행, 다수결 기반 결함 감지\nSelf Purging Redundancy : N개 HW에서 출력 다르면 배제\nWatchdog Timer : Clock, CPU Kick, CPU Reset(Timeout)"},{"토픽":"FTS SW 기술","키워드":"쳌 회 셀 버","도식":null,"정의":null,"내용":"Check Point : SW 오류 시 검사 시점으로 돌아가 재수행\n회복(Recovery) Block : 검사 시점 오류 시\n- 이전 검사점에 돌아가 같은 기능 가진 다른 SW 모듈 수행\nN Self-Checking : 둘 이상의 모듈이 Active-Standby 구조\nN Version : N개 SW 모듈 수행결과 비교, 다수의 결과 채택\n* 외에도 DB 측면의 그림자 페이징, Log 기반, 롤백 등 있음"},{"토픽":"서버 클러스터","키워드":"싱 매 로","도식":null,"정의":"각기 다른 서버를 하나로 묶어 하나의 시스템처럼 동작해 고가용성 제공 기술","내용":"한 시스템 장애 시 클러스터 내 다른 정상 서버가 서비스\n- Single quorum device cluster(모든 노드가 한 쿼럼 연결)\n- Majority node set cluster(Node별로 쿼럼 있음)\n- Local quorum cluster(싱글 노드) : 그냥 하나의 PC인거"},{"토픽":"쿼럼\n(Quorum)","키워드":null,"도식":null,"정의":"클러스터의 구성에 필수적인 항목 또는 정책","내용":"쿼럼 disk가 3이면, Disk array의 5개 Disk 중 3개가 무조건\n활성화 상태여야만 클러스터가 정상 동작 중인 것\n쿼럼 data 보관은 클러스터 구성의 Disk array(DB)를 하나로\n할지, 여러 개 할지 따라 싱글, Majority, Local로 나눔"},{"토픽":"Split brain","키워드":"정 핫 스 오","도식":null,"정의":"클러스터로 구성된 두 sys 간 NW의 일시적 동시 단절 시 모든 노드가 자신을 Primary로 인식하는 현상","내용":"원인 : 짝수 노드 \/ 하트비트 회선 다운 \/ 참여 노드 평등\n다 자기가 Primary인 줄 알아서 공유자원 충돌발생\n정상 상태 > Heartbeat 다운 > Split Brain > sys 오류"},{"토픽":"Split brain 해결 방안","키워드":"낙 개 비 접 강 우","도식":null,"정의":null,"내용":"낙관적 : 정확성 제한(스플릿 시에도 분할 노드 개별 작동)\n비관적 : 가용성 제한(파티셔닝 시 하위 파티션 접근 제한)\n- 과반수 투표자 있는 하위 파티션 지속 사용(쿼럼 홀수)\n강제적 : 우선순위 고정(파티셔닝 시 모든 노드 Down,\n우선순위 고정 된 Primary 노드만 UP)"},{"토픽":"플래시 메모리","키워드":null,"도식":null,"정의":"NAND, NOR에서 사용하며, Program(쓰기), Erase로 전기적으로 data 지우고 쓰는 비휘발성 메모리","내용":"셀이라 불리는 기본 저장 단위의 배열로 이루어짐"},{"토픽":"파일 스토리지","키워드":null,"도식":null,"정의":null,"내용":"폴더 계층 구조"},{"토픽":"블록 스토리지","키워드":null,"도식":null,"정의":"Data를 고정된 크기의 블록 시퀀스로 처리, 각 파일이나 오브젝트를 여러 블록에 분산시킨 저장소","내용":"동일 파일\/Obj 저장 할 때 연속한 블록에 저장할 필요 없음\n- 편한 곳에 저장해 효율 ↑ \/ data 요청 시 블록 병합해 제공\n각 블록은 고유 주소 갖고 서로 독립적이라 계층 필요 없음\n- Data 경로가 반드시 하나만 있는 것은 아니라서 검색 빠름\n보통 저장 영역 네트워크(SAN) 저장소에 배치, 보통 고가임\n- 파일\/Obj 스토리지 시스템이 구축되는 기반임\n- 메타데이터(Obj, 파일 수준 개념) 처리 능력이 제한적"},{"토픽":"오브젝트 스토리지","키워드":"평 확 탄 비 키","도식":null,"정의":"클라우드 환경 등에서 PDF, 비디오, 텍스트 등이 오브젝트 그대로 저장되는 데이터 저장소","내용":"고유 식별자가 있는 평면 주소 공간에 오브젝트 자체로 저장\n- 대용량, 비정형 data 저장 목적\n- 평면이라 탐색\/접근 쉬움, 확장\/탄력성 높음, 비용 효율\n- obj 이름은 Index Table의 Key 역할(이름만 알면 검색됨)\n- 단점 : Obj 조금만 바뀌어도 전체 obj 다 바뀜, 오버헤드↑\n- Obj = 메타 data + 식별자 + data"},{"토픽":"PIM\n(Processing In Memory)","키워드":null,"도식":null,"정의":"메모리에서 저장+연산을 함께 할 수 있는, 메모리 내부에 AI 프로세서를 더한 지능형 반도체","내용":"기존 : 메모리에 data 저장, CPU\/GPU 에서 연산\nAI 연산 시 CPU 연산 속도를 메모리가 못 따라가 성능 제약\n> 메모리가 일부 연산 시 CPU랑 메모리 간 data 전송량 ↓\n구현 방법 : Processing near Mem \/ Processing In Chip"},{"토픽":"PNM\n(Processing Near Memory)","키워드":null,"도식":null,"정의":"실제 메모리 칩 내부가 아닌, 칩 외부 메모리 패키지에 별도 연산 장치 넣고 필요 연산 수행 기술","내용":"DRAM은 노트북, 핸드폰, TV 등 다양한 제품에 똑같이 들어감\n> PIM 기능 필요 없는데 다 PIM 넣어서 팔면 원가 너무 높음\n> DRAM chip은 유지, 필요 시에만 Logic Processor 추가\n(DRAM 근처 DDR DIMM 이나 HBM의 Buffer Die에 추가)"},{"토픽":"PIC\n(Processing In Chip)","키워드":null,"도식":null,"정의":"data가 저장된 DRAM 칩 내에  연산 수행하는 Logic을 추가, data 입출력과 연산을 동시에 하는 효율적 기술","내용":"data 입출력과 동시에 연산하니까 PNM보다 효율적\nbut 비용 부담 큼\n> 상용화도 늦고 아직 대부분이 그냥 컨셉 제안임"},{"토픽":"워치독 타이머\n(Watchdog Timer)","키워드":"킥 리 클 타\n단 다 내 외","도식":null,"정의":"프로그램이 무한 루프에 갇히거나 비정상 상황 등 오류 상황 회피를 위한 전자 타이머","내용":"구성요소 : Kick, Reset, Clock, Timeout\n유형 : 단단계, 다단계, 내부, 외부"},{"토픽":"컴파일러\/인터프리터","키워드":null,"도식":null,"정의":null,"내용":null}]